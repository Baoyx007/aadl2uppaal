<?xml version="1.0" encoding="UTF-8"?>
<sys>
	<declaration>
		//IMA
		int i,eoa;

		typedef struct
		{
		int ModeTypes;
		int v1;
		int v2;
		int e;
		}Segment;
		int iSeg,nSeg;

		typedef struct
		{
		Segment seg[MAsize];
		}MovementAuthority;

		MovementAuthority iMA;
		double
		generateGaussianNoise(double mu, double sigma){
		double u = random(1);
		double v = random(1);
		double x = sqrt((-2) * ln(u)) * cos(2 * PI * v);
		return x*sigma + mu;
		}
	</declaration>
	<train>
		double t_random_delay;

		//if train' v equal to zero
		double v_temp;
		double time;

		void updateTrain(){
		//normal_random()/5 
		a=a-normal_random()/5;
		v_temp = v + a * PERIOD;
		if(v_temp&lt;=0){
		v=0;
		time =
		v / a;
		s =s + v*time + a * time *time /2;
		tt=0;
		return ;
		}
		v = v + a *
		PERIOD;
		s =s + v*PERIOD + a * PERIOD *PERIOD /2;
		tt=0;
		}

		void initilize(){
		tt=0;a=2;
		updateTrain();
		}
	</train>
	<RBC>
		double random_delay;
		// Place local declarations here.
		void
		sendMovementAuthority(){
		int j=0;
		for(j=0;j&lt;MAsize ; j + iMA.seg [ j
		] v1=(MAsize-j)*5+10; iMA.seg [ j ]
		v2=(MAsize-j)*5; iMA.seg [ j ] e=(j+1)*13; } void sendEOA ( eoa=30 +
		i * void connectDelay ( t=0; random_delay=normal_random()*2; }
	</RBC>
	<Controller>
		double c_random_delay;

		//SBI
		bool B1(){
		return (s-start) &lt;=0 || v &lt; iMA.seg[iSeg].v2;
		}

		bool notB1(){
		return (s-start) &gt;0 &amp;&amp; v &gt;= iMA.seg[iSeg].v2;
		}

		bool B2(){
		return (s-start) &lt;=0 || (v*2*2 +
		2*b*s)&lt;iMA.seg[nSeg].v2+(2*b*iMA.seg[iSeg].e);
		}

		bool notB2(){
		return (s-start) &gt;0 &amp;&amp; (v*2*2 +
		2*b*s)&gt;=iMA.seg[nSeg].v2+(2*b*iMA.seg[iSeg].e);
		}

		//EBI
		bool B3(){
		return v &lt; iMA.seg[iSeg].v1;
		}

		bool notB3(){
		return v &gt; iMA.seg[iSeg].v1;
		}


		bool B4(){
		return (v*2*2 + 2*b*s)&lt;iMA.seg[nSeg].v1+(2*b*iMA.seg[iSeg].e);
		}

		bool notB4(){
		return (v*2*2 + 2*b*s)&gt;=iMA.seg[nSeg].v1+(2*b*iMA.seg[iSeg].e);
		}

		void updateSegment(){
		int j = 0;
		for(j=0;j&lt;MAsize;j++){
		if(iMA.seg[j].e-s&lt;0){
		i=j;
		iSeg = j;
		if(j==MAsize-1){
		nSeg = j;
		}else{
		nSeg = j+1;
		}
		j= MAsize;
		}
		}
		}
	</Controller>
	<!-- 
	type:
	connection delay : before ?
	runtime delay : before !
	 -->
	<nond>
		<Ntrain>
		<template>train</template>
		<location>start</location>
		<function>normal</function>
		<type>time</type>
		</Ntrain>
		<NRBC>
		<component>RBC</component>
		<port>r</port>
		<function>normal</function>
		<type >connection delay</type>
		</NRBC>
		<NpController1>
		<template>pController</template>
		<location>READY</location>
		<function>normal</function>
		<type>time</type>
		</NpController1>
	</nond>>
</sys>