<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>clock c;const int PERIOD=2;
const int MAsize=3;
const int SR=3;
const int b=1;
const int start=0;
const int SB_Rate=-8;
const int EB_Rate=-10;
const double PI = 3.1415926;

//------------Lib for Distributions-------------------------

double normal_random()
{
double u = random(1);
double v = random(1);
double x = sqrt((-2) * ln(u)) * cos(2 * PI * v);
if(x&lt;0){return x*-1;}else{ return x;}}

double Normal(double mu, double sigma){
    double u = random(1);
    double v = random(1);
    double x = sqrt((-2) * ln(u)) * cos(2 * PI * v);
    double ret =  x*sigma + mu;
    return ret;
}

double Time_Normal(double mu, double sigma){
    double u = random(1);
    double v = random(1);
    double x = sqrt((-2) * ln(u)) * cos(2 * PI * v);
    double ret =  x*sigma + mu;
    if(ret&lt;0)
        return 0;
else
    return ret;
}

double Uniform(int rangeLow, int rangeHigh) {
    double myRand = random(32767)/(1.0 + 32767); 
    int range = rangeHigh - rangeLow + 1;
    double myRand_scaled = (myRand * range *1.0) + rangeLow;
    return myRand_scaled;
}

int Poisson(double expectedValue) {
  int n = 0; //counter of iteration
  double limit; 
  double x;  //pseudo random number
  limit = exp(-expectedValue);
  x = random(32767) / 32767; 
  while (x &gt; limit) {
    n++;
    x = x* ( random(32767) / 32767);
  }
  return n;
}

double Expon(double x)
{
  double z;                     // Uniform random number (0 &lt; z  &lt; 1 )
  double exp_value;             // Computed exponential value to be returned

  // Pull a uniform random number (0 &lt;  z &lt; 1 )
  do
  {
    z = random(1);
  }
  while ((z == 0) || (z == 1));

  // Compute exponential random variable using inversion method
  exp_value = -x * log(z);

  return(exp_value);
}

double a_strategy(){
    return  1.0;
}
typedef struct
{
    int ModeTypes;
    int v1;
    int v2;
    int e;
}Segment;
int iSeg,nSeg;

typedef struct 
{
    Segment seg[MAsize];
}MovementAuthority;

MovementAuthority iMA;
</declaration>
	<template>
		<name>Ball</name>
		<declaration>
double u_g;
void initialize(){u_g=-1*Normal(9.8,0.3);
 }clock x;
clock v;
clock g;
double c;

clock d_t;
</declaration>
		<location id="id0" x="42" y="85">
			<name x="32" y="55">Ball</name>
			<label kind="invariant" x="0" y="119">x'==v&amp;&amp; v'==u_g &amp;&amp; x&gt;=0 &amp;&amp; g&lt;100</label>
		</location>
		<location id="id1" x="238" y="51">
			<name x="228" y="21">Start</name>
			<urgent/>
		</location>
		<init ref="id1"/>
		<transition>
			<source ref="id0"/>
			<target ref="id0"/>
			<label kind="guard" x="-49" y="22">x&lt;=0</label>
			<label kind="assignment" x="-42" y="51">v = c*v</label>
			<nail x="12" y="55"/>
			<nail x="72" y="55"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id0"/>
			<label kind="assignment" x="102" y="68">v = 0,x=10,c=-0.7,initialize()</label>
		</transition>
	</template>
	<system> system Ball;</system>
	<queries>
		<query>
			<formula>Pr[&lt;=2] (&lt;&gt; Ball.x&lt;5 &amp;&amp; Ball.v &lt;-1)
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>
