package MA
public
	with CTCS_Types;
	with CTCS_Properties;
	with BLESS;
	system sysMA
	end sysMA;

	system implementation sysMA.impl
		subcomponents
			pController: process pController.impl;
			RBC: device RBC.impl;
			Train: abstract Train.impl;
		connections
			conn_position: port Train.ts -> pController.ps;
			conn_velocity: port Train.tv -> pController.pv;
			conn_acc: port pController.pa -> Train.ta;
			conn_req: port pController.pr -> RBC.r;
			conn_ma: port RBC.m ->
					pController.pm;
			conn_ea: port RBC.ea -> pController.pea;
	end sysMA.impl;

	abstract Train
		features
			ts: out data port CTCS_Types::Position;
			tv: out data port CTCS_Types::Velocity;
			ta: in data port CTCS_Types::Acceleration;
	end Train;

	abstract implementation Train.impl
		annex hybrid {**
	
  variables
   ts : CTCS_Types::Position -- train position
   tv : CTCS_Types::Velocity -- train velocity
   ta : CTCS_Types::Acceleration --train acceleration
   t : CTCS_Types::Time     -- train clock time
  constants
   b = 1 mpss    --maximum deceleration of the train, assumed as 1 mpss
  behavior
   Train ::= 'DT 1 ts = tv' & 'DT 1 tv = ta' & 'DT 1 t = 1'
             [[> ts!(ts), tv!(tv),ta?(ta) ]]> Continue
   Continue ::= skip
   RunningTrain ::= ts:= 0 & tv:=0 & ta:=0 & REPEAT(Train)
**};

	end Train.impl;
 
	process pController
		features
			ps: in data port CTCS_Types::Position;
			pv: in data port CTCS_Types::Velocity;
			pa: out data port CTCS_Types::Acceleration;
			pea: in data port CTCS_Types::EOA;
			pr: out event port;
			pm:	in event data port CTCS_Types::MovementAuthority;
	end pController;

	process implementation pController.impl
		subcomponents
			Controller: thread Controller.impl;
		connections
			conn_s: port ps -> Controller.cs;
			conn_v: port pv -> Controller.cv;
			conn_a: port Controller.ca -> pa;
			conn_req: port Controller.r -> pr;
			conn_ma: port pm -> Controller.m;
			conn_ea: port pea -> Controller.ea;
	end pController.impl;

	thread Controller
		features
			ea: in data port CTCS_Types::EOA;
			cs: in data port CTCS_Types::Position {BLESS::Assertion => "<<:=POSITION>>";};
			cv: in data port CTCS_Types::Velocity {BLESS::Assertion => "<<:=VELOCITY>>";};
			ca: out data port CTCS_Types::Acceleration {BLESS::Assertion => "<<:=Acceleration()>>";};
			r: out event port {
						BLESS::Assertion => "<<(s=CTCS_Properties::start) or (s>=(e-SR))>>";};
			m: in event data port CTCS_Types::MovementAuthority {BLESS::Assertion => "<<:=IMA>>";};
		properties
			Dispatch_Protocol => Periodic;
			Period => 200 ms;
	end Controller;

	thread implementation Controller.impl
		annex BLESS {**
assert 
	--<<SRL:x: exists t:CTCS_Types::Time in x-sr .. x that (s@t and v@t)>> --sampling rate limit
	<<SBL: :  (s=CTCS_Properties::start) or ((v < iSeg.v2))>> --service brake limit
	<<EBL: :  (v < iSeg.v1) >> --emergency brake limit
	<<DSPV1: : (((v**2) + (2*b*s)) < (iMA[nSeg.v1] + (2*b*iSeg.e))) >> --DSP for V1
	<<DSPV2: : (s=CTCS_Properties::start) or  (((v**2) + (2*b*s)) < (iMA[nSeg.v2] + (2*b*iSeg.e))) >> --DSP for V2
	
  <<Acceleration: :=
  (NOCHANGE()) -> 0,                                 			
  (not SBL() or not DSPV2()) -> CTCS_Properties::SB_Rate, 
  (not EBL() or not DSPV1()) -> -b,   --CTCS_Properties::EB_Rate = b   			
  (SBL() and DSPV2()) -> xl >> 
  
invariant 
	<<true>>
	
variables
	i: Base_Types::Integer:=0; 
	b : CTCS_Types::Deceleration; 
	v : CTCS_Types::Velocity:=0;
	s : CTCS_Types::Position;
	e : CTCS_Types::EOA;
	xl: CTCS_Types::Acceleration;
	iMA : CTCS_Types::MovementAuthority:=null;
	iSeg, nSeg : CTCS_Types::Segment:=null;
	
states 
	READY : initial state <<(i=0) and (s=CTCS_Properties::start)>> ; 
	GMA   : complete state  <<(i=0) and (s=CTCS_Properties::start)>> ; 
	CMA   : state <<(i=0) and (s=CTCS_Properties::start)>>;
	RETRY : state <<(i=0) and (s=CTCS_Properties::start)>>;
	MFR   : complete state << SBL() and DSPV2()>>;
	CMF   : state <<SBL() and DSPV2()>>;
	SBI   : complete state << not SBL() or not DSPV2() >>; 
	CSB   : state << not SBL() or not DSPV2() >>;
	EBI   : complete state << not EBL() or not DSPV1()  >>;
	STOP  : final state << (not EBL() or not DSPV1()) and v=0>>; 
																	
 transitions
	T0_go: READY -[]-> GMA { 
							<<(i=0) and (s=CTCS_Properties::start)>> 
							r!; 
							<<(i=0) and (s=CTCS_Properties::start)>> 
							(i',s':=i,s) 
							<<(i'=0) and (s'=CTCS_Properties::start)>>
							}; 
	
	T1_MA_Check: GMA -[on dispatch]-> CMA {
											m?(iMA) ;
											 <<(i=0) and (s=CTCS_Properties::start) and (iMA=IMA) >> 
											ea?(e) <<(i=0) and (s=CTCS_Properties::start) and (iMA=IMA) >>
										}; 
	
	
	T2_MA_Ok: CMA -[not (iMA=null)]-> MFR{
										   (iSeg',nSeg',i',v',s',b',iMA':=iSeg, nSeg,i,v,s,b,iMA) 
										   <<(SBL() and DSPV2())^1>>
										  };
	 
    
		
	T3_Move_Check: MFR -[on dispatch]-> CMF{ { <<SBL() and DSPV2()>> 
											cs?(s) <<s=POSITION>> & cv?(v) 	<<SBL() and DSPV2() and v=VELOCITY>> };
											
											 <<SBL() and DSPV2()>>
											 if ( s>=(e-SR) )~>
    											 <<SBL() and DSPV2() and (s>=(e-SR))>>
    											  r!   --- how to check the MA is extended or not
    											<<SBL() and DSPV2()>>	
    										[]
    										   (not (s>=(e-SR)) )~>
    										   	 <<SBL() and DSPV2()>>
    											 skip
    											 <<SBL() and DSPV2()>>	
    										    										
    										fi  <<SBL() and DSPV2()>> 
    										
    										};
    											
	T4_SBI_Point:  CMF -[not ((s=CTCS_Properties::start) or ((v < iSeg.v2))) or
						not ((s=CTCS_Properties::start) or  ((((v**2) + (2*b*s)) < (iMA[nSeg.v2] + (2*b*iSeg.e)))))]-> SBI
												{
												<<not SBL() or not DSPV2()>> ca!(CTCS_Properties::SB_Rate);
												<<not SBL() or not DSPV2()>>
												(iSeg',nSeg',i',v',s',b',iMA':=iSeg, nSeg,i,v,s,b,iMA) 
												<<(not SBL() or not DSPV2())^1>>
												};  
	
	T5_Move_Ok: CMF -[( (s=CTCS_Properties::start) or ((v < iSeg.v2))) or  (((v**2) + (2*b*s)) < (iMA[nSeg.v2] + (2*b*iSeg.e)))]-> MFR
									{
									  ca!(xl);
									 <<SBL() and DSPV2()>> 
									(i,iSeg,nSeg:=i+1,nSeg,iMA[i+2]); 
									<<SBL() and DSPV2()>>   -- What if the MA is extended and what if not, have to update values accordingly
	  								(iSeg',nSeg',i',v',s',b', iMA':=iSeg, nSeg,i,v,s,b, iMA)<<(SBL() and DSPV2())^1>>
	  								}; 
  
  	 
	T6_SBI_Check: SBI -[on dispatch]-> CSB { 
											{<<not SBL() or not DSPV2()>>
											cs?(s) <<s=POSITION>> & cv?(v) 	
											<<(not SBL() or not DSPV2()) and (v=VELOCITY)>> }
										   };
	
	
	T7_SBI_Out: CSB-[ ((s=CTCS_Properties::start) or ((v < iSeg.v2))) and ((s=CTCS_Properties::start) or 
					((((v**2) + (2*b*s)) < (iMA[nSeg.v2] + (2*b*iSeg.e))))) ]-> MFR
		       					{
		       					 <<SBL() and DSPV2()>>
		        				 ca!(xl); 
		      					 <<SBL() and DSPV2()>>
								 (iSeg',nSeg',i',v',s',b', iMA':=iSeg, nSeg,i,v,s,b, iMA)
								 <<(SBL() and DSPV2())^1>>
								 };
		
	
	T8_SBI_Ok: CSB -[not (((s=CTCS_Properties::start) or ((v < iSeg.v2))) and ((s=CTCS_Properties::start) or 
					((((v**2) + (2*b*s)) < (iMA[nSeg.v2] + (2*b*iSeg.e)))))) ]-> SBI
								 {
								 (iSeg',nSeg',i',v',s',b',iMA':=iSeg, nSeg,i,v,s,b,iMA)
								 <<(not SBL() or not DSPV2())^1>>
								 };

	
	T9_MA_NotOk: CMA-[iMA=null]-> RETRY {};
 
    T10_MA_Retry: RETRY -[]-> GMA {(i',s':=i,s)};
	
	T11_EBI_Point: CMF -[not (v < iSeg.v1) or not ((((v**2) + (2*b*s)) < (iMA[nSeg.v1] + (2*b*iSeg.e)))) ]-> EBI
							{
							<<not EBL() or not DSPV1()>> ca!(-b);
							 <<not EBL() or not DSPV1()>> --ca!(CTCS_Properties::EB_Rate)
							(iSeg',nSeg',i',v',s',b',iMA':=iSeg, nSeg,i,v,s,b,iMA) 
							<<(not EBL() or not DSPV1())^1>>
							};  
	T12_Stop: EBI -[v=0]-> STOP {};
	
	T13_EBI_Point: SBI -[not (v < iSeg.v1) or not ((((v**2) + (2*b*s)) < (iMA[nSeg.v1] + (2*b*iSeg.e))))]-> EBI
						   {
							<<not EBL() or not DSPV1()>> ca!(-b); 
							<<not EBL() or not DSPV1()>> --ca!(CTCS_Properties::EB_Rate)
							(iSeg',nSeg',i',v',s',b',iMA':=iSeg, nSeg,i,v,s,b,iMA) 
							<<(not EBL() or not DSPV1())^1>>
						   };
  **};
	end Controller.impl;

	device RBC
		features
			ea: out data port CTCS_Types::EOA;
			r: in event port;
			m: out event data port CTCS_Types::MovementAuthority;
	end RBC;

	device implementation RBC.impl
		annex Uncertainty{**
		variables 
			time dealy_variation applied to ta
 				-- modeling connection delay
 			price acc_variation applied to ta
 				-- modeling rail friction
 		function
 			dealy_variation = Normal(2.2,0.6)
 			acc_variation = Normal(0.5,0.4)			
	**};
	end RBC.impl;

end MA;